<?xml version='1.0' encoding='utf-8'?>

<appendix xml:id="app_gittroubles">
  <title>Common Git Troubles and How To Fix Them</title>

  <introduction>
    <p>
      We all make mistakes, especially with Git. You don't know how many times I have staged the wrong files or committed my changes before realizing I did something wrong. Of coursre, it's best to try and avoid these issues becasue they can cause headaches and frustration. Plus there's usually a little fear involved (did I just erase my edits?) as well as hesitation (Git only does what I tell it, so I have to make sure I do it right). But just in case something happened that you didn't expect or you made a mistake, I have your back. Below are some common mistakes and questions you might ask. 
    </p>
  </introduction>

  <section xml:id="SS_reverseadd">
    <title>Uh Oh, I Staged the Wrong Files!</title>

    <introduction>
      <p>
        Once you get the hang of Git, it's easy to just fly through the three-step process. In doing so, you will inevitably stage (with <c>git add</c>) a file or folder on accident. This is relatively simple to fix. To undo this, follow the next procedure. 
      </p>
    </introduction>
    
    <project xml:id="reverse-git-add">
      <title>Reversing <c>git add</c></title>
      
      <introduction>
        <p>
          Oh shoot. What if you add a file you didn't mean to? This is one reason why there are so many steps to sending files to GitHub. Humans make mistakes and Git gives you the chance to correct any. Should you ever add a file you didn't mean to add, revist this procedure.
        </p>
      </introduction>
      <task>
        <statement>
          <p>
            Identify the file name(s) and extension(s) of the file(s) you mistakenly added.
          </p>
        </statement>
      </task>
      <task>
        <statement>
          <p>
            Use <c>git restore --staged &lt;your-file-name(s)></c> to un-stage any files. Like <c>git add</c>, this command can be run many times.
          </p>
        </statement>
      </task>
      <task>
        <statement>
          <p>
            It might be wise to verify with <c>git status</c> that everything looks good.
          </p>
        </statement>
      </task>
    </project>
  </section>

  <section xml:id="SS_reversecommit">
    <title>Uh Oh, I Committed Too Early!</title>

    <introduction>
      <p>
        We've all been there. You <c>add</c> all the files you need, double check to make sure you aren't missing anything, <c>commit</c> with a message and suddenly remember a file you should have added. Never fear, <c>git reset</c> is here!
      </p>
    </introduction>

    <project xml:id="reverse-git-commit">
      <title>Reversing <c>git commit</c></title>
      
      <task>
        <p>
          You will only need this command: <c>git reset --soft HEAD^1</c>. It should be safe to copy/paste this command directly into your command line and run it.
        </p>
      </task>

      <task>
        <p>
          <c>git reset</c> gives no output so it is super important to check that the command worked with <c>git status</c> (<xref ref="try-git-status"/>). If everything worked, you should see output as if you had used <c>git status</c> after a <c>git add</c> step. 
        </p>
        <p>
          Depending on how many commits you made, you may need to run this above command more than once. If so, make sure to use <c>git status</c> after each try!
        </p>
      </task>

      <task>
        <p>
          Your previously staged files should still exist. From this point, use <c>git add</c> to add your missing file(s) and proceed with <c>git commit</c>.
        </p>
      </task>
    </project>
    
  </section>

  <section xml:id="S_untrackfiles">
    <title>Git Has Been Updating Files, But Now I Don't Want It To</title>
    
    <p>
      This is actually pretty common. Maybe you are writing a book and your abandoned chapters were on GitHub for your editors to look at. Now that the book is published, you don't want those chapters online. Maybe you are using and API and when you were developing a project had your app's API connection keys available and not that the project is public you want to remove the file containing them.
    </p>
    <p>
      When Git is keeping track of files, we say that it is <term>tracking</term> files. Untracking files is not super difficult, but does, like all Git commands, require the command line.
    </p>

    <warning>
      <p>
        Untracking files from Git <em>does not delete them from your local computer</em>. However, the next time you push to GitHub, they will no longer be there. Thus, the next time your collaborators pull from the repository, their copy of the file will be deleted.
      </p>
    </warning>

    <project>
      <title>Untracking Files from Git</title>
      
      <task>
        <statement>
          <p>
            Identify the <em>files</em> you wish to remove from Git's tracking service
          </p>
        </statement>
      </task>

      <task>
        <statement>
          <p>
            Use <c>git rm --cached &lt;filename></c>. You may also add multiple files as done with <c>git add</c> (<xref ref="try-git-add"/>).
          </p>
        </statement>
      </task>

      <task>
        <statement>
          <p>
            Want to untrack folders? You will need the <c>-r</c> recursive option. So, <c>git rm -r --cached &lt;folder-name></c> will do the trick.
          </p>
        </statement>
      </task>

      <task>
        <statement>
          <p>
            The above options will not delete the file(s)/folder(s) from your local computer. If you would like the files deleted and untracked, use the above commands with out the <c>--cached</c> feature: <c>git rm &lt;filenames></c> and <c>git rm -r &lt;folder-names></c>.
          </p>
        </statement>
      </task>
    </project>

  </section>

  <section xml:id="S_forcemerge">
    <title>Git Won't Let Me Pull From Upstream or Origin!</title>
    
    <introduction>
      <p>
        Ah, so you forgot to make a branch. This error happens to me a lot when I have a lot of work on the main branch because I never made a separate branch (not smart of me, I know).
      </p>
      <p>
        Or maybe not. Either way, Git says you have a problem with your code and won't let you merge from upstream. Maybe you get a message like this:
        <console>
          <input>git pull upstream main</input>
          <output>
error: Your local changes to the following files would be overwritten by merge:
        &lt;file-name(s)>
Please commit your changes or stash them before you merge.
Aborting
</output>
</console>
      </p>
      <p>
        This error occurs when you have local, uncommitted changes and a merge from origin or upstream has changes in the same exact places. Git has no idea whose changes to keep so it does nothing. There are a couple of different things you can do in this situation depending on how you feel about your changes.
      </p>
    </introduction>

    <paragraphs>
      <title>Your Local Changes Are Irrelevant and You Want Them Overwritten</title>
      <p>
        This definitely happens! Perhaps you tried a few things and they didn't work so you want to pull from upstream or origin and start over. Maybe you corrected some typos and someone else beat you to it so you want to merge their corrections in and keep working. I could go on and on. It's not difficult at all to force Git to make this happen, just make sure this is what you want to do!
      </p>

      <project>
        <title>Forcing an Upstream or Origin Merge</title>
        
        <task>
          <statement>
            <p>
              First, create a backup branch just in case things go haywire: <c>git branch backup</c>. Since <c>git branch</c> does not automatically switch you to that branch, you are free to carry on.
            </p>
          </statement>
        </task>

        <task>
          <statement>
            <p>
              Now, just fetch the changes. Remember that merging and fetching are separate processes. Fetching just collects the changes, attempting to merge will throw the error. Use <c>git fetch &lt;remote> &lt;branch-name></c>. Example: <c>git fetch upstream main</c>.
            </p>
          </statement>
        </task>

        <task>
          <statement>
            <p>
              Now reset your current branch to the contents you just fetched. This is not a merge, this is a complete reset. You are reverting all of your content to match what you just fetched. This is why we created a backup in case something gets deleted that you didn't want to be.
            </p>
            <p>
              In the event that a file you created gets deleted from the reset, just navigate to the backup branch, stage just the missing file and commit just the missing file to origin. Then pull from origin.
            </p>
            <p>
              But to reset, use <c>git reset --hard &lt;remote>/&lt;branch-name></c>. Continuing the example from above, <c>git reset --hard upstream/main</c>
            </p>
          </statement>
        </task>
      </project>

    </paragraphs>
  </section>

  <section xml:id="S_hub_revert_commit">
    <title>Reverting To a Previous Commit</title>
    
    <p>
      I have never had to do this (yet) so I don't have direct experience here. However, <url href="https://gist.github.com/gunjanpatel/18f9e4d1eb609597c50c2118e416e6a6" visual='gist.github.com/gunjanpatel/18f9e4d1eb609597c50c2118e416e6a6'>user gunjanpatel on GitHub</url> has created a nice guide. It appears that <c>git reset HEAD^ --hard</c> and then <c>git push origin -f</c> will work. The <c>-f</c> switch forces the push and ignores errors.
    </p>
    <p>
      Some of the guide above refers to what is known as a <term>commit hash</term>, a unique string that identifies each commit on GitHub. These are actually so unique that we only need the first few characters of the string to identify the commit. You can find the hash by using <xref ref="S_hub-seecommits"/>. The string is the random numbers/letters found on the right side of each commit.
    </p>

  </section>
  
</appendix>